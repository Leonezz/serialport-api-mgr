// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  async getAllPortInfo(): Promise<Result<PortInfo[], string>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("get_all_port_info") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async openPort(
    portName: string,
    baudRate: number,
    dataBits: string,
    flowControl: string,
    parity: string,
    stopBits: string,
    dataTerminalReady: boolean,
    timeoutMs: number,
  ): Promise<Result<OpenPortResult, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("open_port", {
          portName,
          baudRate,
          dataBits,
          flowControl,
          parity,
          stopBits,
          dataTerminalReady,
          timeoutMs,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Close an open serial port.
   */
  async closePort(portName: string): Promise<Result<null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("close_port", { portName }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Execute a saved command with optional context IDs for logging.
   * The command data is processed and sent to the serial port.
   *
   * Note: The `context_ids` parameter is accepted for API consistency but context
   * association is handled on the frontend side. The context IDs are logged in
   * the tracing span for debugging purposes but are not stored in the backend.
   * Frontend manages the mapping between commands, logs, and their contexts.
   */
  async executeSavedCommand(
    portName: string,
    commandData: number[],
    messageId: string,
    contextIds: string[] | null,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("execute_saved_command", {
          portName,
          commandData,
          messageId,
          contextIds,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Set the Data Terminal Ready (DTR) signal.
   */
  async writeDataTerminalReady(
    portName: string,
    dtr: boolean,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("write_data_terminal_ready", {
          portName,
          dtr,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Set the Request to Send (RTS) signal.
   */
  async writeRequestToSend(
    portName: string,
    rts: boolean,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("write_request_to_send", { portName, rts }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Write data to a serial port.
   */
  async writePort(
    portName: string,
    data: number[],
    messageId: string,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("write_port", { portName, data, messageId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  async debug(prefix: string, content: string): Promise<void> {
    await TAURI_INVOKE("debug", { prefix, content });
  },
  async info(prefix: string, content: string): Promise<void> {
    await TAURI_INVOKE("info", { prefix, content });
  },
  async log(prefix: string, content: string): Promise<void> {
    await TAURI_INVOKE("log", { prefix, content });
  },
  async warn(prefix: string, content: string): Promise<void> {
    await TAURI_INVOKE("warn", { prefix, content });
  },
  async error(prefix: string, content: string): Promise<void> {
    await TAURI_INVOKE("error", { prefix, content });
  },
  async getLogs(
    sessionId: string,
    limit: number,
    offset: number,
  ): Promise<Result<LogEntryDto[], string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_logs", { sessionId, limit, offset }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
};

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

export type DataBits = "Five" | "Six" | "Seven" | "Eight";
export type FlowControl = "Hardware" | "Software" | "None";
export type LogEntryDto = {
  id: number;
  sessionId: string;
  deviceFingerprint: string;
  portName: string;
  direction: string;
  timestamp: number;
  data: number[];
};
/**
 * Result of opening a port, containing the session ID for log queries
 */
export type OpenPortResult = { session_id: string };
export type OpenedPortProfile = {
  baud_rate: number;
  flow_control: FlowControl;
  data_bits: DataBits;
  parity: Parity;
  stop_bits: StopBits;
  carrier_detect: boolean;
  clear_to_send: boolean;
  data_set_ready: boolean;
  ring_indicator: boolean;
  timeout_ms: number;
};
export type Parity = "Odd" | "Even" | "None";
export type PortInfo = {
  port_name: string;
  port_type: PortType;
  port_status: PortStatus;
  bytes_read: number;
  bytes_write: number;
};
export type PortStatus = { Opened: OpenedPortProfile } | "Closed";
export type PortType =
  /**
   * The serial port is connected via USB
   */
  | { UsbPort: UsbPortInfo }
  /**
   * The serial port is connected via PCI (permanent port)
   */
  | "PciPort"
  /**
   * The serial port is connected via Bluetooth
   */
  | "BluetoothPort"
  /**
   * It can't be determined how the serial port is connected
   */
  | "Unknown";
export type StopBits = "One" | "Two";
export type UsbPortInfo = {
  /**
   * Vendor ID
   */
  vid: number;
  /**
   * Product ID
   */
  pid: number;
  /**
   * Serial number (arbitrary string)
   */
  serial_number: string | null;
  /**
   * Manufacturer (arbitrary string)
   */
  manufacturer: string | null;
  /**
   * Product name (arbitrary string)
   */
  product: string | null;
  /**
   * The interface index of the USB serial port. This can be either the interface number of
   * the communication interface (as is the case on Windows and Linux) or the data
   * interface (as is the case on macOS), so you should recognize both interface numbers.
   */
  interface: number | null;
};

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
  | { status: "ok"; data: T }
  | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>;
      };
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T];

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case "listen":
                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
              case "once":
                return (arg: any) => TAURI_API_EVENT.once(name, arg);
              case "emit":
                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
            }
          },
        });
      },
    },
  );
}
